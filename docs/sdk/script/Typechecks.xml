<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>
<!DOCTYPE doc SYSTEM "../../clonk.dtd">
<?xml-stylesheet type="text/xsl" href="../../clonk.xsl"?>
<doc>
<title>Datentypen</title>
<h>Datentypen</h>
<part>

	<text>C4Script unterstützt die folgenden Datentypen für Variablen, Parameter und Rückgabewerte:</text>
	
	<text><table>
		<rowh>
		  <col>Typname</col>
		  <col>Voller Name</col>
		  <col>Variableninhalt</col>
		  <col>Beispiel</col>
		</rowh>
		<row>
		  <col><code>int</code></col>
		  <col>Integer</col>
		  <col>Eine ganze Zahl im Bereich von -2.147.483.648 bis +2.147.483.647.</col>
		  <col><code>42 </code></col>
		</row>
		<row>
		  <col><code>bool</code></col>
		  <col>Boolean</col>
		  <col>"wahr" (Wert <code>true</code>) oder "falsch" (Wert <code>false</code>). Wird von vielen Kontrollstrukturen wie <funclink>if</funclink> und <funclink>while</funclink> als Parameter erwartet.</col>
		  <col><code>true </code></col>
		</row>
		<row>
		  <col><code>id</code></col>
		  <col>Definitions-ID</col>
		  <col>ID einer Objektdefinition (siehe <emlink href="definition/index.html#ObjektundEntwicklerIdentifikation">Objektdefinitionen</emlink>). Wird sofort in eine Proplist umgewandelt.</col>
		  <col><code>Clonk </code></col>
		</row>
		<row>
		  <col><code>string</code></col>
		  <col>Zeichenkette</col>
		  <col>Ein beliebiger Text.</col>
		  <col><code>"Dies ist ein Text!" </code></col>
		</row>
		<row>
		  <col><code>array</code></col>
		  <col>Array</col>
		  <col>Ein Typ, der eine Reihe weiterer durchnummerierter Variablen enthält, deren Anzahl mit <funclink>GetLength</funclink> abgefragt werden kann, und die mit <code><em>array</em>[<em>index</em>]</code> abgerufen werden können. Ab CR.</col>
		  <col><code>[0,42,Clonk] </code></col>
		</row>
		<row>
		  <col><code>proplist</code></col>
		  <col>Objekt</col>
		  <col>Ein allgemeiner Objekttyp. Mit <funclink>GetProperty</funclink> und <funclink>SetProperty</funclink> können Eigenschaften abgefragt bzw. gesetzt werden.
		  Wenn die Eigenschaft <code>"Prototype"</code> gesetzt ist und eine nicht gesetzte Eigenschaft abgefragt wird, wird im Prototyp nachgeguckt.</col>
		  <col><code>{ foo = 0, "bar baz" = 42, Prototype = Clonk }</code></col>
		</row>
		<row>
		  <col><code>object</code></col>
		  <col>Spielobjekt</col>
		  <col>Verweis auf ein im Spiel existierendes Objekt. Hat keine direkte Darstellung. Siehe z.B. <funclink>FindObject</funclink>()</col>
		  <col>CreateObject(Clonk)</col>
		</row>
	</table></text>
	
	<text>Außerdem gibt es noch zwei spezielle Typen:</text>
	
	<text><ul>
	<li><code>any</code>: Der Typ ist nicht bekannt oder egal. "0" hat immer diesen Typ.</li>
	<li><code>&amp;</code>: Der Wert ist eine Referenz - z.B. auf eine Variable. Er verhält sich genau wie der Zielwert, kann aber gesetzt werden (z.B. mit dem Operator "<code>=</code>"). Siehe auch <emlink href="script/Funcs.html#referenzen">Referenzparameter</emlink>.</li>
	</ul></text>
	
	<h>Arrays</h>
	<part>
		<text>Arrays können entweder direkt durch <code>[<em>Ausdruck 1</em>, <em>Ausdruck 2</em>, ...]</code> oder <funclink>CreateArray</funclink>() erstellt werden. Sie werden bei Zugriff auf ein Element gegebenenfalls automatisch verlängert, jedoch ist es schneller, das Array gleich mit der benötigten Länge zu erstellen. Wird ein Array einer Variablen zugewiesen oder einer Funktion übergeben, bekommt diese Variable eine eigene Kopie des Arrays. Das eigentliche Kopieren wird aber erst ausgeführt, wenn es nötig ist. Wenn das Array einer Funktion zum Ändern übergeben werden soll, muss ein Referenzparameter verwendet werden.
		</text>
		<text>Zugriff auf ein Element <code>i</code> eines Arrays <code>a</code> erfolgt über <code>a[i]</code>. Dabei entspricht <code>i=0</code> dem ersten Element. Für negative Indizes wird vom Ende des Arrays gezählt, so dass <code>a[-1]</code> auf das letzte Element des Arrays zugreift.</text>
		<text>Man kann eine Kopie eines Teilbereichs eines Arrays mit <code>a[i:j]</code> erzeugen. Das resultierende Array enthält alle Einträge, deren Indizes im halboffenen Intervall <code>[i,j)</code> liegen. Negative Indizes werden dabei wie beim Zugriff auf einzelne Elemente interpretiert. Beide Indizes sind optional und werden als <code>0</code> bzw. <code>-1</code> aufgefasst, falls sie nicht angegeben sind.</text>
		<h>Beispiel 1</h>
<code>func ArraySum(array a)
{
  var l = GetLength(a);
  var result = 0;
  for (var i = 0; i &lt; l; ++i)
  {
    result += a[i];
  }
  return (result);
}</code>
		<text>Diese Funktion summiert alle Elemente eines Arrays.</text>
		<h>Beispiel 2</h>
<code>func RandomID()
{
  var a = [Clonk, WIPF, BIRD, HUT1];
  return (a[Random(4)]);
}</code>
		<text>Diese Funktion wählt zufällig aus einer der vier ids aus und gibt diese zurück.</text>
		<h>Beispiel 3</h>
<code>func DetonateNearest()
{
  var a = <funclink>FindObjects</funclink>(<funclink>Find_ID</funclink>(Dynamite), Sort_Distance());
  for (var dyna in a[:6])
  {
    dyna->DoExplode();
  }
}</code>
		<text>Diese Funktion ruft <code>DoExplode()</code> auf die sechs naheliegendsten Dynamit-Objekte auf.</text>
	</part>

	<h>Konvertierung</h>
	
	<text>Aus folgender Tabelle kann entnommen werden, welche Typen automatisch konvertiert werden und wo ein Fehler ausgelöst wird:</text>
	
	<text><table>
		<rowh>
		 <col>nach -&gt;</col>
		 <col><code>int</code></col>
		 <col><code>bool</code></col>
		 <col><code>object</code></col>
		 <col><code>string</code></col>
		 <col><code>array</code></col>
		 <col><code>proplist</code></col>
		</rowh>
		<row>
		 <col><code>int</code></col>
		 <col>OK</col>
		 <col>OK</col>
		 <col>wenn 0</col>
		 <col>wenn 0</col>
		 <col>wenn 0</col>
		 <col>wenn 0</col>
		</row>
		<row>
		 <col><code>bool</code></col>
		 <col>OK</col>
		 <col>OK</col>
		 <col>Error</col>
		 <col>Error</col>
		 <col>Error</col>
		 <col>Error</col>
		</row>
		<row>
		 <col><code>object</code></col>
		 <col>Error</col>
		 <col>OK</col>
		 <col>OK</col>
		 <col>Error</col>
		 <col>Error</col>
		 <col>OK</col>
		</row>
		<row>
		 <col><code>string</code></col>
		 <col>Error</col>
		 <col>OK</col>
		 <col>Error</col>
		 <col>OK</col>
		 <col>Error</col>
		 <col>Error</col>
		</row>
		<row>
		 <col><code>array</code></col>
		 <col>Error</col>
		 <col>OK</col>
		 <col>Error</col>
		 <col>Error</col>
		 <col>OK</col>
		 <col>Error</col>
		</row>
		<row>
		 <col><code>proplist</code></col>
		 <col>Error</col>
		 <col>OK</col>
		 <col>maybe</col>
		 <col>Error</col>
		 <col>Error</col>
		 <col>OK</col>
		</row>
	</table></text>

	<h>Erklärung der Tabelle:</h>
	<text><ul>
		<li>Konvertierung nach bool ist generell erlaubt. Sie ergibt für jeden Wert außer 0 <code>true</code>.</li>
		<li>Wenn ein Objekt in eine Proplist konvertiert wurde, kann es wieder in ein Objekt konvertiert werden. Ansonsten können Proplists nicht in Objekte konvertiert werden.</li>
		<li>Eine <code>0</code> kann in alles andere konvertiert werden. Sie verhält sich dann wie <code>any</code></li>
	</ul></text>
	
</part>

<author>Günther</author><date>2006-2010</date>
<author>PeterW</author><date>April 2006</date>

</doc>
